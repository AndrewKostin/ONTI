# -*- coding: utf-8 -*-
"""tuii_2019.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LroXEyr2-eFfvCQ56YQk-dwXUKw9snOC

![](https://s.tcdn.co/d06/e20/d06e2057-5c13-324d-b94f-9b5a0e64f2da/14.png)
"""

import numpy as np
import random as rd
import time

exp = 10**10 #на поле будет использоваться в качестве стены

def sozd_wall(pole):
    for i in range(size_y + 1):
        pole[i][0] = exp
        pole[i][size_x] = exp
    for i in range(size_x + 1):
        pole[0][i] = exp
        pole[size_y][i] = exp
"""
пока ненужная нам функция, если понадобиться то будем использовать
"""

def current(Xo, Yo, X, Y):
    if ((Y-Yo)==1):
        return 'b' #back
    elif ((X-Xo)==1):
        return 'r' #right
    elif ((Yo-Y)==1):
        return 'f' #forward
    elif ((Xo-X)==1):
        return 'l' #left
    else:
        return 'not identified'

def yes_or_no(pole, current, X, Y):
    if (current=='b'):
        if (Y==(size_y - 1)):
            return 'n'
        else:
            return 'y'
        
    elif (current=='r'):
        if (X==(size_x - 1)):
            return 'n'
        else:
            return 'y'
        
    elif (current=='f'):
        if (Y==0):
            return 'n'
        else:
            return 'y'
        
    else:
        if (X==0):
            return 'n'
        else:
            return 'y'

def min_kolvo(pole, X, Y, Xo, Yo):
    
    if (yes_or_no(pole, 'f', X, Y)=='y'):
        f = pole[Y-1][X]
    else:
        f = exp
        
    if (yes_or_no(pole, 'r', X, Y)=='y'):
        r = pole[Y][X+1]
    else:
        r = exp
        
    if (yes_or_no(pole, 'b', X, Y)=='y'):
        b = pole[Y+1][X]
    else:
        b = exp
        
    if (yes_or_no(pole, 'l', X, Y)=='y'):
        l = pole[Y][X-1]
    else:
        l = exp 
    
    cur = current(Xo, Yo, X, Y)
    
    min_kolvo = min(f, r, b, l)
   
    if (cur == 'f'):
        if (min_kolvo==f):
            return 'f'
        elif (min_kolvo==l):
            return 'l'
        elif (min_kolvo==b):
            return 'b'
        else:
            return 'r'
        
    elif (cur == 'r'):
        if (min_kolvo==l):
            return 'l'
        elif (min_kolvo==f):
            return 'f'
        elif (min_kolvo==r):
            return 'r'
        else:
            return 'b'
     
    elif (cur == 'l'):
        if (min_kolvo==f):
            return 'f'
        elif (min_kolvo==l):
            return 'l'
        elif (min_kolvo==b):
            return 'b'
        else:
            return 'r'
        
    else:
        if (min_kolvo==l):
            return 'l'
        elif (min_kolvo==f):
            return 'f'
        elif (min_kolvo==r):
            return 'r'
        else:
            return 'b'

def turn(pole, X, Y, Xo, Yo):
    
    cur= min_kolvo(pole, X, Y, Xo, Yo)
    
    if (cur == 'f'):
        Xo, Yo = X, Y
        X = X
        Y = Y - 1
    elif (cur == 'b'):
        Xo, Yo = X, Y
        X = X
        Y = Y + 1
    elif (cur == 'r'):
        Xo, Yo = X, Y
        X = X + 1
        Y = Y
    else:
        Xo, Yo = X, Y
        X = X - 1
        Y = Y
        
    return X, Y, Xo, Yo, cur

def walls(massiv, pole, size_x, size_y):
    s = ''
    for a in range(0, len(massiv), 2):
        x, y = massiv[a] - 1, massiv[a+1] - 1
        if ((x<size_x) and (y<size_y)):    
            pole[y][x] = exp
            s+= ' ok '
        else:
            s += ' impossible '
    return s

def proverka_clear_cletok(pole, x, y, size_x, size_y):
    massiv = []
    if (x>0):
        if (pole[y][x-1]!=exp):
            massiv += [(x-1), y]
            
    if (y>0):
        if (pole[y-1][x]!=exp):
            massiv += [x, (y-1)]
            
    if (x!=(size_x-1)):
        if (pole[y][x+1]!=exp):
            massiv += [(x+1), y]
            
    if (y!=(size_y-1)):
        if (pole[y+1][x]!=exp):
            massiv += [x, (y+1)]
            
    return massiv

def rekursiya(pole_p, x, y, size_x, size_y):
    if ((x==(size_x-1)) and (y==(size_y-1))):
        return 'yes'
    
    else:
        massiv = proverka_clear_cletok(pole_p, x, y, size_x, size_y)
        if (len(massiv)==0):
            return 'bl*n'
        
        for i in range(0, len(massiv), 2):
            pole_p[massiv[i+1]][massiv[i]] = exp
            rekursiya(pole_p, massiv[i], massiv[i+1], size_x, size_y)        
            
    if (pole_p[size_y-1][size_x-1]==exp):
        return 'yes'
    else:
        return 'bl*n'

size_x = 6 #размер матрицы x
size_y = 6 #размер матрицы y
size = size_x

"""#ПЕРЕБОР"""

t1 = time.time()
ma = 0
count = 0
pole_m = []
itera = 500000
for i in range(itera):
  massiv = []
  kol = 0
  
  if (i/itera)==0.01:
    print ("1% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/itera)==0.1:
    print ("10% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/itera)==0.2:
    print ("20% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/itera)==0.3:
    print ("30% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/itera)==0.4:
    print ("40% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/itera)==0.5:
    print ("50% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/itera)==0.6:
    print ("60% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/itera)==0.7:
    print ("70% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/itera)==0.8:
    print ("80% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/itera)==0.9:
    print ("90% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)
  if (i/(itera-1))==1:
    print ("100% done time teaching is: ", (time.time()- t1)/60, "max now:", ma)

  
  
  for i in range(rd.randint(1,(size_x)*(size_y-1)-1)):
    a = rd.randint(1,(size_x-1)*(size_y-1))
    x = a%size
    y = a//size
    massiv += [x, y]
  pole = np.zeros((size_y, size_x))
  X, Y = 0, 0 #переменные, которые определяют положение жука на поле
  Xo, Yo = 0, 0 #переменные, которые определяют предидущее положение жука на поле
  walls(massiv, pole, size_x, size_y)
  pole_p = pole
  
    
  if (rekursiya(pole_p, 0, 0, size_x, size_y)=='yes'):
    pole = np.zeros((size_y, size_x))
    walls(massiv, pole, size_x, size_y)
    pole[0][0] = 1
    while (X!=(size_x - 1)) or (Y!=(size_y - 1)):
      X, Y, Xo, Yo, cur = turn(pole, X, Y, Xo, Yo)
      pole[Y][X] += 1
      kol += 1
      #print (X, ' ', Y, ' ', kol, ' ', cur)
  else:
    #print("not possible")
    count += 1
      
    
  if (kol>ma):
    ma = kol
    pole = np.zeros((size_y, size_x))
    walls(massiv, pole, size_x, size_y)
    pole_m = pole
t2 = time.time()
dt = (t2-t1)/60
print("time is:", dt)
print("wrong is:", count/itera)
print("score is:", ma)
print(pole_m)

"""![Image of Yaktocat](https://s.tcdn.co/869/281/86928106-6812-340c-9d51-70ef0f8a4771/33.png)

#ГЕНЕТИЧЕСКИЙ АЛГОРИТМ

![](https://s.tcdn.co/afd/2d9/afd2d9fe-6d3a-37b8-babb-97dfb9e243a5/18.png)
"""

def create_population(kol, size_x, size_y):
  population = []
  for i in range(kol): #создаем популяцию
    massiv = []
    for i in range(rd.randint(0,((size_x)*(size_y))//2)): #создаем одно поле со стенками
      a = rd.randint(1,(size_x)*(size_y)-1)
      x = a%size_x
      y = a//size_x
      massiv += [x, y]
    pole_ = np.zeros((size_y, size_x)) 
    walls(massiv, pole_, size_x, size_y) #получили поле со стенами
    population += [pole_] #добавили в популяцию
  return population
    
def create_population_v2(kol, size_x, size_y):
  population = np.random.randint(2, size=(kol, size_x, size_y))
  return population

def reproduction(pole_1, pole_2):
  pole_3 = []
  up = pole_1[:len(population[0])//2][:]  
  down = pole_2[len(population[0])//2:][:]
  pole_3 = np.vstack((up, down))
  return pole_3

def count_rez(population):
  rez = []
  for i in range(len(population.copy())):
    pole_p = population[i].copy()
    pole = population[i].copy()
    if (rekursiya(pole_p.copy(), 0, 0, size_x, size_y)=='yes'):
      kol = 0
      pole[0][0] = 1
      X, Y = 0, 0
      Xo, Yo = 0, 0
      while (X!=(size_x - 1)) or (Y!=(size_y - 1)):
              X, Y, Xo, Yo, cur = turn(pole, X, Y, Xo, Yo)
              pole[Y][X] += 1
              kol += 1
              #print (X, ' ', Y, ' ', kol, ' ', cur)
      rez += [kol]
    else:
      rez += [0]
  return rez

def findall(pole, chto):
  s = []
  for i in range(len(pole)):
    for a in range(len(pole)):
      if (pole[i][a]==chto):
        s+=[i, a]
  return s

def mutation(pole, exp, size):
  steni = findall(pole, exp)
  if (len(steni)==0):
    a = rd.randint(1,(size)*(size)-1)
    x = a%size
    y = a//size
    pole[y][x] = exp
  else:
    a = rd.randint(0, size - 1)
    b = rd.randint(0, size - 1)
    x = a
    y = b
    pole[y][x] = 0
  return pole

"""#ОСНОВНАЯ ПРОГА ГЕНЕТИЧЕСКОГО АЛГОРИТМА"""

size_x = 3 #размер матрицы x
size_y = 3 #размер матрицы y
k = 300 #кол-во экземпляров в популяции
schastie = 100 #кол-во счастливичков для размножения
ff = schastie//2

population = create_population(k, size_x, size_y)

rez = count_rez(population.copy())
ma_o = 0
ma_n = max(rez)
population[0]

ma_n

ind = rez.index(ma_n)
pole_m = population[ind]
pole_m

"""Цикл который работает пока результат не понижается"""
ma_c = 0
t1 = time.time()
itera = 0
pole_m = []
ind = 0
const = 100 #максимальное кол-во размножений
print("teaching... ")
while (ma_n>=ma_o):
  itera+=1
  if (ma_n>ma_c):
    ma_c = ma_n
    ind = rez.index(ma_c)
    pole_m = population[ind]

  rez = count_rez(population.copy())
  ma_o = max(rez)
  prob = [rez[i]/sum(rez) for i in range(len(rez))] #делаем массив вероятностей для размножения
  select = np.random.choice(len(rez), schastie, replace=False, p = prob) #выбираем k счастливчиков для размножения
  for a in range(ff):
    pole_new = reproduction(population[select[rd.randint(0, len(select) - 1)]], population[select[rd.randint(0, len(select) - 1)]]) #само рахмножение
    pole_new = mutation(pole_new, exp, size_x) #мутация
    population += [pole_new] #добавили в популяцию
  rez = count_rez(population.copy())
  ma_n = max(rez)
  if (ma_n<ma_o):
    break
    
  if (itera/const==0.01):
    print("1% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/const==0.1):
    print("10% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/const==0.2):
    print("20% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/const==0.3):
    print("30% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/const==0.4):
    print("40% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/const==0.5):
    print("50% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/const==0.6):
    print("60% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/const==0.7):
    print("70% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/const==0.8):
    print("80% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/const==0.9):
    print("90% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  elif (itera/(const)==1.0):
    print("100% teaching time is", (time.time()-t1)/60, "max is:", ma_c, "количество особей:", len(population))
  
  if (itera==const):
    break

  
print("complete!") 

    
t2 = time.time()
dt = (t2-t1)/60
print("time is: ", dt)
print("itera is: ", itera)
print("max is: ", ma_c)
print("pole max is:")
print(pole_m)

"""#В поиске новых идей
![Image of Yaktocat](https://chpic.su/_data/stickers/b/blobbyyyy/blobbyyyy_001.webp)

![](https://s.tcdn.co/869/281/86928106-6812-340c-9d51-70ef0f8a4771/39.png)
"""

